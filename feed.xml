

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://xiabao.top:18888//</id>
  <title>Fanventory</title>
  <subtitle>有空的时候随便写点东西.</subtitle>
  <updated>2023-07-19T18:43:42+08:00</updated>
  <author>
    <name>Fanventory</name>
    <uri>http://xiabao.top:18888//</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://xiabao.top:18888//feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://xiabao.top:18888//"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 Fanventory </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>读书笔记 —— 最大文件描述符数</title>
    <link href="http://xiabao.top:18888//posts/%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%95%B0/" rel="alternate" type="text/html" title="读书笔记 —— 最大文件描述符数" />
    <published>2023-07-19T14:35:00+08:00</published>
  
    <updated>2023-07-19T14:35:00+08:00</updated>
  
    <id>http://xiabao.top:18888//posts/%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%95%B0/</id>
    <content src="http://xiabao.top:18888//posts/%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%95%B0/" />
    <author>
      <name>Fanventory</name>
    </author>

  
    
    <category term="Reading Notes" />
    
    <category term="Linux高性能服务器编程" />
    
  

  
    <summary>
      





      进程池概述

  本节介绍了Linux的最大文件描述符数的限制，分为用户级限制和系统级限制两种，前者是一个用户能打开的文件描述符数，后者是所有用户能打开的文件描述符数。因为系统分配给应用程序的文件描述符是有限制的，所以我们通常关闭那些不需要的文件描述符，避免占用资源。





最大文件描述符数

系统分配给应用程序的文件描述符是有限制的，所以我们总是关闭那些不需要的文件描述符，释放它们占用的资源。比如作为守护进程运行的服务器程序就总是关闭标准输入、标准输出和标准错误这3个文件描述符。

Linux中，应用程序能打开的文件描述符数量有两个层次的限制：

  用户级限制
  系统级限制


用户级限制

用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数。
我们可以通过以下命令查看用户级文件描述符数限制：

ulimit -n


我们可以通过以下命令将用户级文件描述符数限制...
    </summary>
  

  </entry>

  
  <entry>
    <title>读书笔记 —— 进程池和线程池_1</title>
    <link href="http://xiabao.top:18888//posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_2/" rel="alternate" type="text/html" title="读书笔记 —— 进程池和线程池_1" />
    <published>2023-07-19T09:34:00+08:00</published>
  
    <updated>2023-07-19T09:34:00+08:00</updated>
  
    <id>http://xiabao.top:18888//posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_2/</id>
    <content src="http://xiabao.top:18888//posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_2/" />
    <author>
      <name>Fanventory</name>
    </author>

  
    
    <category term="Reading Notes" />
    
    <category term="Linux高性能服务器编程" />
    
  

  
    <summary>
      





      进程池概述

  本节我们实现了简单的两种线程池模型：基于半同步/半异步模式的线程池、基于半同步/半反应堆模式的线程池。前者可以保证同一个客户连接的所有任务都由一个子进程来处理，后者通过工作队列解除了主线程和工作线程的耦合关系，通用性更高。





半同步/半异步线程池的实现

综合前面的讨论，我们实现一个半同步/半异步模式的线程池。该线程池可以避免父、子进程之间传递文件描述符，还保证同一个客户连接的所有任务都由一个子进程来处理。

//  filename: processpool.h
#ifndef PROCESSPOOL.H
#define PROCESSPOOL.H

#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;ar...
    </summary>
  

  </entry>

  
  <entry>
    <title>读书笔记 —— 进程池和线程池_1</title>
    <link href="http://xiabao.top:18888//posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_1/" rel="alternate" type="text/html" title="读书笔记 —— 进程池和线程池_1" />
    <published>2023-07-18T19:16:00+08:00</published>
  
    <updated>2023-07-18T19:16:00+08:00</updated>
  
    <id>http://xiabao.top:18888//posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_1/</id>
    <content src="http://xiabao.top:18888//posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_1/" />
    <author>
      <name>Fanventory</name>
    </author>

  
    
    <category term="Reading Notes" />
    
    <category term="Linux高性能服务器编程" />
    
  

  
    <summary>
      





      进程池概述

  本节探讨了进程池(线程池)的一些概念，已经它们解决了什么问题。由于进程池和线程池在模型上类似，所以我们只讨论进程池。进程池是为了解决动态创建进程耗费时间、占用不必要的内核资源，且创建的子进程只能为一个客户服务等问题。所以我们预先在服务器创建的一组子进程，这些子进程都运行相同的代码，并具有相同的属性。进程池处理多客户任务时，需要注意两个问题：1.监听socket和连接socket是否都由主进程统一管理？这个问题涉及到服务器并发模型的确立。2.一个客户连接的所有任务是否始终由一个子进程来处理？这个问题涉及到服务器的是有状态的还是无状态的。





进程池(线程池)概述

动态创建子进程(子线程)的缺点：

  耗费时间，导致客户响应慢
  创建的子进程(子线程)只能为一个客户服务，如果客户较多，过多的进程(线程)切换会耗费大量CPU时间
  动态创建的子进程是当前进程...
    </summary>
  

  </entry>

  
  <entry>
    <title>读书笔记 —— 多线程编程_7</title>
    <link href="http://xiabao.top:18888//posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_7/" rel="alternate" type="text/html" title="读书笔记 —— 多线程编程_7" />
    <published>2023-07-17T14:23:00+08:00</published>
  
    <updated>2023-07-17T14:23:00+08:00</updated>
  
    <id>http://xiabao.top:18888//posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_7/</id>
    <content src="http://xiabao.top:18888//posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_7/" />
    <author>
      <name>Fanventory</name>
    </author>

  
    
    <category term="Reading Notes" />
    
    <category term="Linux高性能服务器编程" />
    
  

  
    <summary>
      





      多线程环境

  本节探讨了多线程环境中容易遇到的一些问题。首先，Linux有些库函数是线程安全的，而有些库函数不是线程安全的。多线程环境中调用线程不安全的库函数会导致不可预期的后果。不过线程不安全的库函数占比少，而且大部分由线程安全版本。其次，线程执行fork调用后会复制父进程，但只会创建一个子线程。我们需要注意复制的子进程会继承父进程的互斥锁，这容易导致子进程死锁。线程库中提供了pthread_atfork函数来保证fork调用后互斥锁处于解锁状态。最后，在我们探讨了多线程环境下的信号问题，每个线程都可以设置信号掩码，但是容易出现逻辑混乱、共享信号处理函数等问题，所以需要一个专门的线程处理信号。





线程安全

如果一个函数能被多个线程同时调用而且不发生竞态条件，我们称它是线程安全的(thread safe)，或者说它是可重入函数。
Linux中只有一小部分函数是不可重入的...
    </summary>
  

  </entry>

  
  <entry>
    <title>读书笔记 —— 多线程编程_6</title>
    <link href="http://xiabao.top:18888//posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_6/" rel="alternate" type="text/html" title="读书笔记 —— 多线程编程_6" />
    <published>2023-07-17T11:14:00+08:00</published>
  
    <updated>2023-07-17T11:14:00+08:00</updated>
  
    <id>http://xiabao.top:18888//posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_6/</id>
    <content src="http://xiabao.top:18888//posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_6/" />
    <author>
      <name>Fanventory</name>
    </author>

  
    
    <category term="Reading Notes" />
    
    <category term="Linux高性能服务器编程" />
    
  

  
    <summary>
      





      条件变量

  本节介绍了条件变量的相关API，包括初始化条件变量、销毁条件变量、唤醒一个或全部等待条件变量的线程、等待条件变量。





条件变量

条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。
对比互斥锁，互斥锁是同步线程对共享数据的访问，而条件变量同步的是线程之间的共享数据的值。

pthread_cond_init

下面是pthread_cond_init函数，功能是初始化条件变量，其定义如下：

#include &amp;lt;pthread.h&amp;gt;
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);


参数和返回值：

  cond: 目标条件变量
  cond_attr: 指定条件变量的属性，如果传入NU...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://fanventory.github.io/</id>
  <title>Fanventory</title>
  <subtitle>有空的时候随便写点东西.</subtitle>
  <updated>2023-07-19T20:13:58+08:00</updated>
  <author>
    <name>Fanventory</name>
    <uri>https://fanventory.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://fanventory.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://fanventory.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 Fanventory </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>读书笔记 —— Github + Jekyll</title>
    <link href="https://fanventory.github.io/posts/Github+Jekyll/" rel="alternate" type="text/html" title="读书笔记 —— Github + Jekyll" />
    <published>2023-07-19T15:34:00+08:00</published>
  
    <updated>2023-07-19T15:34:00+08:00</updated>
  
    <id>https://fanventory.github.io/posts/Github+Jekyll/</id>
    <content src="https://fanventory.github.io/posts/Github+Jekyll/" />
    <author>
      <name>Fanventory</name>
    </author>

  
    
    <category term="other" />
    
  

  
    <summary>
      





      jekyll

  如何使用jekyll和GitHub搭建一个免费博客。





创建github账号和仓库


  
    创建github账号
  
  
    建立一个仓库，仓库名是访问地址，一般格式为: XXX.github.io
  


安装ruby环境


  下载ruby+Devkit (www.ruby-lang.org)
  安装 Ruby+Devkit 3.2.2-1(x86).exe


安装RubyGems


  下载RubyGems (www.ruby-lang.org)
  解压
  运行命令


# 进入你解压的文件夹
cd D:\rubyGems\rubygems-3.4.17
ruby setup.rb
gem install jekyll


创建博客


  创建博客模板


cd XXX # 进入你放置博客文件的位置
jekyll n...
    </summary>
  

  </entry>

  
  <entry>
    <title>读书笔记 —— 最大文件描述符数</title>
    <link href="https://fanventory.github.io/posts/%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%95%B0/" rel="alternate" type="text/html" title="读书笔记 —— 最大文件描述符数" />
    <published>2023-07-19T14:35:00+08:00</published>
  
    <updated>2023-07-19T14:35:00+08:00</updated>
  
    <id>https://fanventory.github.io/posts/%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%95%B0/</id>
    <content src="https://fanventory.github.io/posts/%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%95%B0/" />
    <author>
      <name>Fanventory</name>
    </author>

  
    
    <category term="Reading Notes" />
    
    <category term="Linux高性能服务器编程" />
    
  

  
    <summary>
      





      进程池概述

  本节介绍了Linux的最大文件描述符数的限制，分为用户级限制和系统级限制两种，前者是一个用户能打开的文件描述符数，后者是所有用户能打开的文件描述符数。因为系统分配给应用程序的文件描述符是有限制的，所以我们通常关闭那些不需要的文件描述符，避免占用资源。





最大文件描述符数

系统分配给应用程序的文件描述符是有限制的，所以我们总是关闭那些不需要的文件描述符，释放它们占用的资源。比如作为守护进程运行的服务器程序就总是关闭标准输入、标准输出和标准错误这3个文件描述符。

Linux中，应用程序能打开的文件描述符数量有两个层次的限制：

  用户级限制
  系统级限制


用户级限制

用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数。
我们可以通过以下命令查看用户级文件描述符数限制：

ulimit -n


我们可以通过以下命令将用户级文件描述符数限制...
    </summary>
  

  </entry>

  
  <entry>
    <title>读书笔记 —— 进程池和线程池_2</title>
    <link href="https://fanventory.github.io/posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_2/" rel="alternate" type="text/html" title="读书笔记 —— 进程池和线程池_2" />
    <published>2023-07-19T09:34:00+08:00</published>
  
    <updated>2023-07-19T09:34:00+08:00</updated>
  
    <id>https://fanventory.github.io/posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_2/</id>
    <content src="https://fanventory.github.io/posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_2/" />
    <author>
      <name>Fanventory</name>
    </author>

  
    
    <category term="Reading Notes" />
    
    <category term="Linux高性能服务器编程" />
    
  

  
    <summary>
      





      线程池的实现

  本节我们实现了简单的两种线程池模型：基于半同步/半异步模式的线程池、基于半同步/半反应堆模式的线程池。前者可以保证同一个客户连接的所有任务都由一个子进程来处理，后者通过工作队列解除了主线程和工作线程的耦合关系，通用性更高。





半同步/半异步线程池的实现

综合前面的讨论，我们实现一个半同步/半异步模式的线程池。该线程池可以避免父、子进程之间传递文件描述符，还保证同一个客户连接的所有任务都由一个子进程来处理。

//  filename: processpool.h
#ifndef PROCESSPOOL.H
#define PROCESSPOOL.H

#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;a...
    </summary>
  

  </entry>

  
  <entry>
    <title>读书笔记 —— 进程池和线程池_1</title>
    <link href="https://fanventory.github.io/posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_1/" rel="alternate" type="text/html" title="读书笔记 —— 进程池和线程池_1" />
    <published>2023-07-18T19:16:00+08:00</published>
  
    <updated>2023-07-18T19:16:00+08:00</updated>
  
    <id>https://fanventory.github.io/posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_1/</id>
    <content src="https://fanventory.github.io/posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_1/" />
    <author>
      <name>Fanventory</name>
    </author>

  
    
    <category term="Reading Notes" />
    
    <category term="Linux高性能服务器编程" />
    
  

  
    <summary>
      





      进程池概述

  本节探讨了进程池(线程池)的一些概念，已经它们解决了什么问题。由于进程池和线程池在模型上类似，所以我们只讨论进程池。进程池是为了解决动态创建进程耗费时间、占用不必要的内核资源，且创建的子进程只能为一个客户服务等问题。所以我们预先在服务器创建的一组子进程，这些子进程都运行相同的代码，并具有相同的属性。进程池处理多客户任务时，需要注意两个问题：1.监听socket和连接socket是否都由主进程统一管理？这个问题涉及到服务器并发模型的确立。2.一个客户连接的所有任务是否始终由一个子进程来处理？这个问题涉及到服务器的是有状态的还是无状态的。





进程池(线程池)概述

动态创建子进程(子线程)的缺点：

  耗费时间，导致客户响应慢
  创建的子进程(子线程)只能为一个客户服务，如果客户较多，过多的进程(线程)切换会耗费大量CPU时间
  动态创建的子进程是当前进程...
    </summary>
  

  </entry>

  
  <entry>
    <title>读书笔记 —— 多线程编程_7</title>
    <link href="https://fanventory.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_7/" rel="alternate" type="text/html" title="读书笔记 —— 多线程编程_7" />
    <published>2023-07-17T14:23:00+08:00</published>
  
    <updated>2023-07-17T14:23:00+08:00</updated>
  
    <id>https://fanventory.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_7/</id>
    <content src="https://fanventory.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_7/" />
    <author>
      <name>Fanventory</name>
    </author>

  
    
    <category term="Reading Notes" />
    
    <category term="Linux高性能服务器编程" />
    
  

  
    <summary>
      





      多线程环境

  本节探讨了多线程环境中容易遇到的一些问题。首先，Linux有些库函数是线程安全的，而有些库函数不是线程安全的。多线程环境中调用线程不安全的库函数会导致不可预期的后果。不过线程不安全的库函数占比少，而且大部分由线程安全版本。其次，线程执行fork调用后会复制父进程，但只会创建一个子线程。我们需要注意复制的子进程会继承父进程的互斥锁，这容易导致子进程死锁。线程库中提供了pthread_atfork函数来保证fork调用后互斥锁处于解锁状态。最后，在我们探讨了多线程环境下的信号问题，每个线程都可以设置信号掩码，但是容易出现逻辑混乱、共享信号处理函数等问题，所以需要一个专门的线程处理信号。





线程安全

如果一个函数能被多个线程同时调用而且不发生竞态条件，我们称它是线程安全的(thread safe)，或者说它是可重入函数。
Linux中只有一小部分函数是不可重入的...
    </summary>
  

  </entry>

</feed>


